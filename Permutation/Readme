# Approach
This solution uses backtracking and recursion to generate all permutations.
Key Idea
  Fix one element at a time at the current index.
  Swap it with every possible element that can occupy that position.
  Recursively generate permutations for the remaining part of the array.
  Backtrack by undoing the swap to restore the original state.

# Algorithm
1.Start from index 0.
2.For each index idx:
  Swap the element at idx with every element from idx to n-1.
  Recursively call the function for idx + 1.
  Swap back (backtracking).
3.When idx == nums.size(), store the current permutation.

#Explanation
getPerms
Recursive helper function.
Generates permutations by swapping elements in place.
Uses backtracking to explore all possibilities.

permute
Initializes the result vector.
Calls the recursive helper function.
Returns all generated permutations.

EAMPLE
Input
nums = [1, 2, 3]

Output
[
 [1,2,3],
 [1,3,2],
 [2,1,3],
 [2,3,1],
 [3,2,1],
 [3,1,2]
]
