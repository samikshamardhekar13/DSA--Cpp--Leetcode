Given an integer array nums, return all the unique triplets [nums[i], nums[j], nums[k]] such that:
i ≠ j ≠ k
nums[i] + nums[j] + nums[k] = 0
The solution must not contain duplicate triplets.

# Approach
This solution uses:
  1.Sorting
  2.Two-pointer technique
Steps:
1.Sort the input array.
2.Iterate through the array, fixing one element at a time.
3.Use two pointers (left and right) to find pairs that sum to the negative of the fixed element.
4.Skip duplicate elements to avoid repeating triplets.

# Algorithm
1.Sort the array.
2.Loop from index 0 to n-1:
  Skip duplicate elements.
3.Initialize two pointers:
  j = i + 1
  k = n - 1
4.While left < right:
  Calculate the sum.
  Adjust pointers based on the sum.
  Store valid triplets and skip duplicates.

EXAMPLE:
Input
nums = [-1, 0, 1, 2, -1, -4]

Output
[[-1, -1, 2], [-1, 0, 1]]
